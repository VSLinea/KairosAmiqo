---
status: draft
phase: 2
document_id: P2.S1.T5
canonical: true
type: database-schema
last_reviewed: 2025-11-18
owner: amiqlab
related:
  - /docs/00-architecture-overview.md
  - /docs/01-data-model.md
  - /docs/02-api-contracts.md
  - /docs/03-backend-structure.md
  - /tracking/TRACKING.md
---

# Kairos Amiqo — Database Schema (Draft)

This document defines the **canonical PostgreSQL schema** for the Kairos Amiqo backend.  
Full content will be populated in subsequent subtasks of P2.S1.T5.

It serves as the authoritative source for:

- All tables (negotiations, events, users, supporting tables)
- Data types and constraints
- Indexing strategy
- Migration rules
- Referential integrity boundaries
- E2EE-compatible storage design (encrypted vs metadata fields)

Do not modify this header or structure outside the Phase 2 documentation workflow.

---

## Overview

This document defines the canonical PostgreSQL schema for the Kairos Amiqo backend.  
It translates the conceptual data model (Negotiation, Participant, Proposed Slot, Proposed Venue, Event) into concrete SQL tables, columns, constraints, and indexes.

The schema is optimized for:

- Reliable, consistent negotiation lifecycle storage
- Efficient querying of upcoming and past invitations
- Clear separation between metadata and encrypted content
- Compatibility with the Fastify + PostgreSQL backend described in `docs/03-backend-structure.md`
- Future scaling to hundreds of thousands of users and millions of negotiations

This document is the single source of truth for:

- Table definitions
- Data types and nullability
- Primary and foreign keys
- Indexing strategy
- Migration rules and evolution constraints

All application code, migrations, and queries MUST remain aligned with this schema.

## Design Principles

The Kairos Amiqo database schema follows these core principles:

1. **Metadata only; content is E2EE.**  
   - The database stores only negotiation metadata (owner, participants, timestamps, state, proposed slots/venues).  
   - Any message content or sensitive negotiation details remain encrypted on the client side and are never stored in plaintext.

2. **UUID primary keys everywhere.**  
   - All primary keys are `UUID` values generated by the backend or database.  
   - No auto-increment integers are used for identifiers.  
   - This simplifies sharding and avoids ID collisions across environments.

3. **Minimal and explicit relationships.**  
   - Foreign keys are used only where they add real integrity value (e.g., linking events to negotiations, linking negotiations to users).  
   - Relationships are defined explicitly with clear `ON DELETE` / `ON UPDATE` behavior.

4. **Append-friendly, not write-heavy.**  
   - Negotiations are expected to change state a limited number of times.  
   - The schema is optimized for reading lists of invitations and a small number of updates per negotiation.

5. **Time-zone safe.**  
   - All timestamps are stored as `TIMESTAMPTZ` in UTC.  
   - Client-side code is responsible for localizing time zones.

6. **Index only what we query.**  
   - Indexes exist for access patterns we know we need:
     - Find negotiations by owner
     - Find negotiations where a given user is a participant
     - Filter/sort by state and relevant timestamps
   - Additional indexes are added only after measured need.

7. **Forward-compatible.**  
   - The schema is designed to allow new columns and tables without breaking existing queries.  
   - Soft-additive changes (new optional columns, new tables) are preferred over destructive refactors.

## Schema Summary

At a high level, the Kairos Amiqo database schema consists of the following core tables:

- **negotiations**  
  Stores the core negotiation record:
  - Unique ID (UUID)
  - Owner (user ID)
  - Canonical state (awaiting_invites, awaiting_replies, confirmed, cancelled, expired)
  - Intent category (coffee, lunch, dinner, etc.)
  - Proposed slots and venues (as structured JSON)
  - Expiry and creation timestamps

- **participants**  
  Stores one row per participant per negotiation:
  - Negotiation ID (FK to negotiations)
  - Participant user ID
  - Participant status (invited, accepted, rejected, countered, organizer)
  - Optional display name
  This table makes participant queries efficient and prevents heavy JSON scanning.

- **proposed_slots**  
  Stores proposed time slots per negotiation:
  - Negotiation ID (FK)
  - Slot index or ID
  - Start time (TIMESTAMPTZ)
  - Optional duration
  This supports querying and ranking proposals without parsing JSON blobs.

- **proposed_venues**  
  Stores proposed venues per negotiation:
  - Negotiation ID (FK)
  - Venue identifier or name
  - Optional metadata (e.g., address, provider ID)
  This allows independent indexing and filtering on venues.

- **events**  
  Stores the final, confirmed events derived from negotiations:
  - Event ID (UUID)
  - Owner (user ID)
  - Linked negotiation ID (FK)
  - Start time, optional end time
  - Status (draft, confirmed, cancelled)
  - Metadata payload (JSONB) for future extensions

Later sections will specify the exact columns, types, constraints, and indexes for each of these tables.

## Tables

### negotiations

The `negotiations` table stores the core metadata for every negotiation created in Kairos Amiqo.  
It contains **no encrypted content**, only metadata required for lifecycle, state transitions, and participant access control.

#### Table Definition (SQL)

```sql
CREATE TABLE negotiations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    owner UUID NOT NULL,  -- Firebase user ID (sub)
    state TEXT NOT NULL CHECK (state IN (
        'awaiting_invites',
        'awaiting_replies',
        'confirmed',
        'cancelled',
        'expired'
    )),

    intent_category TEXT NOT NULL, -- constrained via CHECK below

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,

    /* Metadata-only fields */
    proposed_slots_json JSONB DEFAULT '[]'::jsonb NOT NULL,
    proposed_venues_json JSONB DEFAULT '[]'::jsonb NOT NULL,

    /* Optional metadata for future agent mode */
    agent_mode BOOLEAN NOT NULL DEFAULT FALSE,
    agent_round INTEGER DEFAULT 0 CHECK (agent_round >= 0),

    /* Foreign Keys */
    CONSTRAINT fk_negotiations_owner FOREIGN KEY (owner)
        REFERENCES app_users(id)
        ON DELETE CASCADE,

    /* Intent category constraint */
    CONSTRAINT chk_intent_category CHECK (intent_category IN (
        'coffee','lunch','dinner','drinks','gym','walk','movie',
        'concert','study','game','brunch'
    ))
);
```

**Note**:  
Participants, proposed slots, and proposed venues are stored in their own tables (`participants`, `proposed_slots`, `proposed_venues`). The JSON fields above exist only as convenience snapshots returned by API.

#### Column-by-Column Specification

| Column | Type | Null | Default | Notes |
|--------|------|------|---------|-------|
| `id` | UUID | NOT NULL | `gen_random_uuid()` | Primary key |
| `owner` | UUID | NOT NULL | — | Firebase sub of the creator |
| `state` | TEXT | NOT NULL | `awaiting_invites` | Must follow negotiation lifecycle |
| `intent_category` | TEXT | NOT NULL | — | Event type category (coffee/lunch/etc.) |
| `created_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Auto-updated on changes |
| `expires_at` | TIMESTAMPTZ | NOT NULL | — | Hard expiry for negotiations |
| `proposed_slots_json` | JSONB | NOT NULL | `[]` | Snapshot for API responses |
| `proposed_venues_json` | JSONB | NOT NULL | `[]` | Snapshot for API responses |
| `agent_mode` | BOOLEAN | NOT NULL | `FALSE` | Reserved for future autonomous negotiation |
| `agent_round` | INTEGER | NULL | `0` | Future multi-round flows |

#### Indexing Strategy for negotiations

```sql
-- Frequently queried by owner
CREATE INDEX idx_negotiations_owner ON negotiations(owner);

-- State + expiry filtering (list of invitations)
CREATE INDEX idx_negotiations_state_expires
ON negotiations(state, expires_at);

-- Find active negotiations quickly
CREATE INDEX idx_negotiations_active
ON negotiations(expires_at)
WHERE state IN ('awaiting_invites', 'awaiting_replies');
```

**Design notes**:
- Indexes match the read patterns of the iOS app.
- Composite index (state, expires_at) supports pagination.
- Partial index on active states reduces noise in queries.

#### Referential Integrity Notes

- `owner` → `app_users.id` ensures only valid users can create negotiations.
- `participants`, `proposed_slots`, `proposed_venues`, and `events` tables will reference `negotiations.id`.
- Negotiation deletion cascades automatically to child rows.

#### E2EE Boundary Notes (Backend Perspective)

- Backend never stores decrypted content.
- Only metadata is stored in this table.
- Message bodies, chat exchanges, and AI agent reasoning remain encrypted and out of scope.
- Proposed slots/venues JSON columns are mirrored convenience views and must never contain sensitive plaintext.

### participants

The `participants` table stores one row per participant per negotiation.  
It enables efficient querying of participant membership, status tracking, and authorization checks without scanning JSON arrays.

#### Table Definition (SQL)

```sql
CREATE TABLE participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    negotiation_id UUID NOT NULL,
    user_id UUID NOT NULL,  -- Firebase user ID (sub)

    status TEXT NOT NULL CHECK (status IN (
        'invited',
        'accepted',
        'rejected',
        'countered',
        'organizer'
    )),

    display_name TEXT,  -- Optional convenience metadata

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    /* Foreign Keys */
    CONSTRAINT fk_participants_negotiation FOREIGN KEY (negotiation_id)
        REFERENCES negotiations(id)
        ON DELETE CASCADE,

    /* Uniqueness constraint: one participant row per user per negotiation */
    CONSTRAINT uq_participants_negotiation_user UNIQUE (negotiation_id, user_id)
);
```

#### Column-by-Column Specification

| Column | Type | Null | Default | Notes |
|--------|------|------|---------|-------|
| `id` | UUID | NOT NULL | `gen_random_uuid()` | Primary key |
| `negotiation_id` | UUID | NOT NULL | — | FK to negotiations |
| `user_id` | UUID | NOT NULL | — | Firebase sub of participant |
| `status` | TEXT | NOT NULL | — | Participant response status |
| `display_name` | TEXT | NULL | — | Optional name for UI convenience |
| `created_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | When participant was added |
| `updated_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Last status change |

#### Indexing Strategy for participants

```sql
-- Find all participants for a negotiation
CREATE INDEX idx_participants_negotiation ON participants(negotiation_id);

-- Find all negotiations a user is participating in
CREATE INDEX idx_participants_user ON participants(user_id);

-- Filter by user and status (e.g., "all accepted invitations")
CREATE INDEX idx_participants_user_status ON participants(user_id, status);
```

**Design notes**:
- Primary access pattern: "Find all participants for negotiation X"
- Secondary pattern: "Find all negotiations user Y is part of"
- Composite index supports filtering by status

#### Referential Integrity Notes

- Participants MUST reference an existing negotiation.
- Deleting a negotiation cascades to delete its participants automatically.
- Backend must enforce no duplicate `(negotiation_id, user_id)` pairs via the `UNIQUE` constraint.
- The organizer (creator) MUST be present as a participant row with `status = 'organizer'`.
- User IDs are NOT dereferenced to an external user table; Firebase is the identity provider.

#### E2EE Boundary Notes (Backend Perspective)

- No encrypted content is stored in this table.
- Only metadata (user_id, role, status) is stored.
- Client applications keep full participant names local; `display_name` is optional convenience metadata only.
- Backend authorization checks use `user_id` to verify participant membership.

### proposed_slots

The `proposed_slots` table stores proposed time slots for each negotiation.  
It enables efficient querying and ranking of time proposals without parsing JSON blobs, and supports filtering by time range.

#### Table Definition (SQL)

```sql
CREATE TABLE proposed_slots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    negotiation_id UUID NOT NULL,
    slot_index INTEGER NOT NULL CHECK (slot_index >= 0),

    starts_at TIMESTAMPTZ NOT NULL,
    duration_minutes INTEGER CHECK (duration_minutes > 0),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    /* Foreign Keys */
    CONSTRAINT fk_slots_negotiation FOREIGN KEY (negotiation_id)
        REFERENCES negotiations(id)
        ON DELETE CASCADE,

    /* Uniqueness constraint: one slot per index per negotiation */
    CONSTRAINT uq_slots_negotiation_index UNIQUE (negotiation_id, slot_index),

    /* Validation: slot must be in the future or very recent */
    CONSTRAINT chk_slots_future CHECK (starts_at > NOW() - INTERVAL '1 second')
);
```

#### Column-by-Column Specification

| Column | Type | Null | Default | Notes |
|--------|------|------|---------|-------|
| `id` | UUID | NOT NULL | `gen_random_uuid()` | Primary key |
| `negotiation_id` | UUID | NOT NULL | — | FK to negotiations |
| `slot_index` | INTEGER | NOT NULL | — | Zero-based ordering within negotiation |
| `starts_at` | TIMESTAMPTZ | NOT NULL | — | Proposed start time (UTC) |
| `duration_minutes` | INTEGER | NULL | — | Optional duration (must be > 0 if present) |
| `created_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | When slot was proposed |
| `updated_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Last modification time |

#### Indexing Strategy for proposed_slots

```sql
-- Find all slots for a negotiation
CREATE INDEX idx_slots_negotiation ON proposed_slots(negotiation_id);

-- Query slots by time range (e.g., "all proposals this week")
CREATE INDEX idx_slots_starts_at ON proposed_slots(starts_at);
```

**Design notes**:
- Primary access pattern: "Load all proposed slots for negotiation X"
- Secondary pattern: "Find all negotiations with slots in time range Y to Z"
- `slot_index` enables deterministic ordering without relying on timestamps
- Time-based index supports future calendar integration features

#### Referential Integrity Notes

- Proposed slots MUST reference an existing negotiation.
- Deleting a negotiation cascades to delete its proposed slots automatically.
- Backend must enforce unique `(negotiation_id, slot_index)` pairs via the `UNIQUE` constraint.
- Slot values are metadata only — never encrypted.
- Slot times must remain in UTC (`TIMESTAMPTZ` handles time zone conversion automatically).

#### E2EE Boundary Notes (Backend Perspective)

- Backend never decrypts anything.
- `proposed_slots` stores ONLY metadata (time, duration, ordering).
- Clients may include additional encrypted context (e.g., venue notes, participant preferences) separately; that content is NOT stored in this table.
- All slot data is queryable and filterable by the backend for consensus detection and scheduling logic.

### proposed_venues

The `proposed_venues` table stores proposed venue options for each negotiation.  
It enables efficient querying and filtering of venue proposals, supports external provider integration (e.g., Google Places), and maintains deterministic ordering for UI consistency.

#### Table Definition (SQL)

```sql
CREATE TABLE proposed_venues (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    negotiation_id UUID NOT NULL,
    venue_index INTEGER NOT NULL CHECK (venue_index >= 0),

    name TEXT NOT NULL CHECK (length(name) > 0),
    provider_id TEXT,  -- Optional external provider reference (e.g., Google Places ID)

    metadata JSONB DEFAULT '{}'::jsonb NOT NULL,  -- Non-sensitive UI-only info

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    /* Foreign Keys */
    CONSTRAINT fk_venues_negotiation FOREIGN KEY (negotiation_id)
        REFERENCES negotiations(id)
        ON DELETE CASCADE,

    /* Uniqueness constraint: one venue per index per negotiation */
    CONSTRAINT uq_venues_negotiation_index UNIQUE (negotiation_id, venue_index)
);

-- Note: metadata should contain only JSON objects (not arrays or scalars).
-- Postgres cannot enforce JSON shape constraints natively; application must validate.
```

#### Column-by-Column Specification

| Column | Type | Null | Default | Notes |
|--------|------|------|---------|-------|
| `id` | UUID | NOT NULL | `gen_random_uuid()` | Primary key |
| `negotiation_id` | UUID | NOT NULL | — | FK to negotiations |
| `venue_index` | INTEGER | NOT NULL | — | Zero-based ordering within negotiation |
| `name` | TEXT | NOT NULL | — | Human-readable venue name (must be non-empty) |
| `provider_id` | TEXT | NULL | — | External provider reference (Google Places, Apple Maps, etc.) |
| `metadata` | JSONB | NOT NULL | `{}` | Non-sensitive UI-only metadata (address, coordinates, etc.) |
| `created_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | When venue was proposed |
| `updated_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Last modification time |

#### Indexing Strategy for proposed_venues

```sql
-- Find all venues for a negotiation
CREATE INDEX idx_venues_negotiation ON proposed_venues(negotiation_id);

-- Search venues by name (for future real-time search enhancements)
CREATE INDEX idx_venues_name ON proposed_venues(name);
```

**Design notes**:
- Primary access pattern: "Load all proposed venues for negotiation X"
- Secondary pattern: "Search venues by name across negotiations" (planned feature)
- `venue_index` enables deterministic ordering for UI display
- `provider_id` intentionally not indexed yet; indexing will be added when external provider integration is implemented
- Name index supports future autocomplete and search features

#### Referential Integrity Notes

- Proposed venues MUST reference an existing negotiation.
- Deleting a negotiation cascades to delete its proposed venues automatically.
- Backend must enforce unique `(negotiation_id, venue_index)` pairs via the `UNIQUE` constraint.
- `metadata` must contain only non-sensitive UI fields (e.g., address, coordinates, category).
- E2EE context (encrypted venue notes, participant comments) must NEVER be stored in this table.

#### E2EE Boundary Notes (Backend Perspective)

- `proposed_venues` is metadata-only; no encrypted content is stored.
- Clients hold encrypted venue notes, preferences, and private comments separately.
- Backend treats `metadata` JSON as opaque: no enrichment, merging, or decryption.
- All venue data is queryable and filterable by the backend for consensus detection and venue selection logic.
- Future AI agent features may read venue metadata but must never decrypt client-side content.

### events

The `events` table stores finalized or draft calendar events derived from negotiations.  
It contains only **metadata**, never encrypted content.

#### Table Definition (SQL)

```sql
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    owner UUID NOT NULL,              -- Firebase user ID (sub)
    negotiation_id UUID,              -- Optional link back to source negotiation

    status TEXT NOT NULL CHECK (status IN (
        'draft',
        'confirmed',
        'cancelled'
    )),

    starts_at TIMESTAMPTZ NOT NULL,
    ends_at TIMESTAMPTZ,              -- Optional; may be NULL for all-day or simple events

    title TEXT,                       -- Optional UI convenience field
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    /* Foreign Keys */
    CONSTRAINT fk_events_owner FOREIGN KEY (owner)
        REFERENCES app_users(id)
        ON DELETE CASCADE,

    CONSTRAINT fk_events_negotiation FOREIGN KEY (negotiation_id)
        REFERENCES negotiations(id)
        ON DELETE SET NULL
);
```

#### Column-by-Column Specification

| Column | Type | Null | Default | Notes |
|--------|------|------|---------|-------|
| `id` | UUID | NOT NULL | `gen_random_uuid()` | Primary key |
| `owner` | UUID | NOT NULL | — | Firebase sub of event owner |
| `negotiation_id` | UUID | NULL | — | Optional FK to negotiations.id |
| `status` | TEXT | NOT NULL | — | draft, confirmed, or cancelled |
| `starts_at` | TIMESTAMPTZ | NOT NULL | — | Event start time (UTC) |
| `ends_at` | TIMESTAMPTZ | NULL | — | Optional end time (UTC) |
| `title` | TEXT | NULL | — | Optional human-readable title |
| `metadata` | JSONB | NOT NULL | `{}` | Non-sensitive metadata only |
| `created_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | NOT NULL | `NOW()` | Last modification time |

#### Indexing Strategy for events

```sql
-- Find events by owner and start time (primary dashboard query)
CREATE INDEX idx_events_owner_starts_at
ON events(owner, starts_at);

-- Filter by status (e.g., only confirmed events)
CREATE INDEX idx_events_status
ON events(status);

-- Link back from negotiation → events (history / audit)
CREATE INDEX idx_events_negotiation
ON events(negotiation_id);
```

**Design notes**:
- `idx_events_owner_starts_at` supports "all upcoming events for this user" queries.
- `idx_events_status` enables quick filtering for confirmed vs draft vs cancelled.
- `idx_events_negotiation` supports reverse lookups from a negotiation to its derived events.

#### Referential Integrity Notes

- `owner` → `app_users.id` ensures every event is tied to a valid user.
- `negotiation_id` is optional:
  - For events created from negotiations, it points to the source `negotiations.id`.
  - For standalone events (future use), it may be NULL.
- Deleting an `app_users` record cascades and removes associated events.
- Deleting a negotiation sets `events.negotiation_id` to NULL:
  - The event can remain on the user's calendar even if the negotiation record is removed.
- Backend logic must ensure:
  - `owner` of the event matches `owner` of the negotiation when `negotiation_id` is not NULL.
  - Status transitions remain consistent with the business rules in the API contracts doc.

#### E2EE Boundary Notes (Backend Perspective)

- `events` stores only metadata:
  - Times, status, links to negotiation, non-sensitive metadata.
  - No decrypted invitation messages, chat content, or notes are stored here.
- `metadata` is restricted to:
  - Non-sensitive UI hints (color, icon, source="negotiation", etc.).
  - It must never include plaintext private notes or conversation content.
- Any encrypted notes or detailed descriptions remain client-side and are not persisted in this table.

## Data Types

This section defines the canonical PostgreSQL data types used across the Kairos Amiqo backend.  
All migrations, queries, and schema evolution must adhere to the rules below.

### 1. UUID (Primary Keys & Foreign Keys)

- **Type:** `UUID`
- **Generation:** `gen_random_uuid()` (from pgcrypto)
- **Usage:** All primary keys and foreign keys
- **Rationale:**  
  - Avoids collisions across environments  
  - Enables offline creation  
  - Safe for sharding and replication  
  - Non-sequential → improved privacy  

### 2. TIMESTAMPTZ (Time-zone Safe Timestamps)

- **Type:** `TIMESTAMPTZ`
- **Always stored in UTC**
- **Used for:**  
  - `created_at`, `updated_at`  
  - `starts_at`, `ends_at`  
  - `expires_at`  
- **Rationale:**  
  - Eliminates ambiguity in multi-region behavior  
  - Client localizes times

### 3. JSONB (Structured Metadata Only)

- **Type:** `JSONB`
- **Usage Rules:**  
  - Only used for **non-sensitive metadata**  
  - Must NOT contain decrypted or private content  
  - Always use JSONB (`jsonb`) not JSON (`json`)  

Examples:  
- `metadata` in events  
- Snapshot fields (`proposed_slots_json`, `proposed_venues_json`)  

### 4. TEXT (Free-form Categoricals)

- **Type:** `TEXT`
- **Usage:**  
  - Intent categories  
  - Negotiation states  
  - Participant status  
  - Optional display names  
  - Optional titles  

### 5. Normalized ENUM via CHECK Constraints

Kairos **does not use PostgreSQL ENUM types**.

Instead, we use TEXT + CHECK constraints:

```sql
CHECK (state IN (...))
```

**Advantages:**  
- Easy to extend  
- No destructive ENUM alteration migrations  
- Works with JSONB snapshots  
- Cleaner schema evolution

### 6. INTEGER (Indexed Numeric Values)

- **Type:** `INTEGER`
- **Used for:**  
  - Agent round counters  
  - Slot indices  
  - Venue indices  
  - Duration minutes

**Rules:**  
- Must be ≥ 0 unless otherwise specified  
- Indexed where ordering is required

### 7. BOOLEAN

- **Type:** `BOOLEAN`
- **Used for:**  
  - `agent_mode`  
- **Defaults:** Always explicitly defined (DEFAULT FALSE)

### 8. Foreign Key NULL Semantics

- **ON DELETE CASCADE** for ownership and containment (participants, slots, venues)
- **ON DELETE SET NULL** for optional links (events → negotiations)

## Constraints

This section defines all database-enforced, application-enforced, and migration-impact constraints across the Kairos Amiqo PostgreSQL schema. These rules govern negotiation behavior, participant membership, event integrity, and future schema evolution. All backend logic and migrations must remain compliant with these constraints.

### 1. Database-Level Constraints (SQL-Enforced)

These constraints are enforced directly by PostgreSQL.

**1.1 Primary Keys**  
- All tables use UUID primary keys generated by `gen_random_uuid()`.

**1.2 Foreign Keys**  
- `participants.negotiation_id` → `negotiations.id` (ON DELETE CASCADE)
- `proposed_slots.negotiation_id` → `negotiations.id` (ON DELETE CASCADE)
- `proposed_venues.negotiation_id` → `negotiations.id` (ON DELETE CASCADE)
- `events.negotiation_id` → `negotiations.id` (ON DELETE SET NULL)
- `negotiations.owner` → `app_users.id` (ON DELETE CASCADE)
- `events.owner` → `app_users.id` (ON DELETE CASCADE)

**1.3 NOT NULL Constraints**

Ensure the existence of essential metadata:
- `negotiations.state`, `intent_category`, `created_at`, `updated_at`, `expires_at`, `owner`
- `participants.negotiation_id`, `participants.user_id`, `participants.status`
- `proposed_slots.starts_at`, `proposed_slots.slot_index`

**1.4 UNIQUE Constraints**

```sql
UNIQUE (negotiation_id, user_id)        -- participants
UNIQUE (negotiation_id, slot_index)     -- proposed_slots
UNIQUE (negotiation_id, venue_index)    -- proposed_venues
```

**1.5 CHECK Constraints**

Negotiation state:
```sql
CHECK (state IN ('awaiting_invites','awaiting_replies','confirmed','cancelled','expired'))
```

Intent category:
```sql
CHECK (intent_category IN ('coffee','lunch','dinner','drinks','gym','walk','movie','concert','study','game','brunch'))
```

Participant status:
```sql
CHECK (status IN ('invited','accepted','rejected','countered','organizer'))
```

Slot time:
- `starts_at > NOW() - INTERVAL '1 second'`
- `duration_minutes > 0` (if present)

**1.6 JSONB Type Safety**

Snapshots must be arrays:
```sql
CHECK (jsonb_typeof(proposed_slots_json) = 'array')
CHECK (jsonb_typeof(proposed_venues_json) = 'array')
```

### 2. Application-Level Constraints (Not SQL-Enforced)

These are enforced in backend logic and documented here for correctness.

**2.1 Organizer Membership**  
- The negotiation owner must appear in the participants table with `status = 'organizer'`.

**2.2 Allowed State Transitions**

Valid transitions:
- `awaiting_invites` → `awaiting_replies`
- `awaiting_replies` → `confirmed` / `cancelled`
- `confirmed` → `cancelled`
- `awaiting_invites`/`awaiting_replies` → `expired` (time-based)

**2.3 Participant Status Logic**  
- Only invited participants may accept/reject/counter.
- Organizer cannot reject.
- Counter moves state to `awaiting_replies`.

**2.4 Expiry Rules**  
- `expires_at` must be after `created_at`.
- Backend must forbid updates to expired negotiations.

**2.5 Consistency Rules**  
- Slot/venue indices must be consecutive from 0..N-1.
- A negotiation with state `confirmed` must have exactly one selected slot and venue.
- `agent_mode = TRUE` requires valid agent metadata.

**2.6 E2EE Boundaries**  
- Backend must never inspect or store decrypted content.
- Only metadata may be persisted.

### 3. Migration Impact Constraints (Future-Proof Rules)

These rules define how constraints evolve safely.

**3.1 Frozen Constraints (Do Not Change After Launch)**  
- Primary keys (UUID everywhere)
- Foreign key graph between negotiations, participants, slots, venues, events
- E2EE storage boundaries
- ON DELETE semantics
- Organizer requirement

**3.2 Evolvable with Caution (Requires a Safe Migration Sequence)**

Adding a new negotiation state:

Sequence:
1. Add new value to CHECK constraint using `NOT VALID`
2. Backfill data if needed
3. `VALIDATE CONSTRAINT`
4. Update backend logic

Adding new intent categories:

Same as above.

**3.3 Freely Evolvable (No Migration Hazard)**  
- Adding optional columns with defaults
- Adding new tables not referenced by existing FKs
- Adding new JSONB metadata fields

### 4. Migration Sequencing Examples

**4.1 Safe CHECK Constraint Extension**

```sql
ALTER TABLE negotiations
  ADD CONSTRAINT chk_negotiation_state_new CHECK (state IN (...)) NOT VALID;
ALTER TABLE negotiations VALIDATE CONSTRAINT chk_negotiation_state_new;
```

**4.2 Backfilling Required Columns**

```sql
ALTER TABLE participants ADD COLUMN display_name TEXT;
UPDATE participants SET display_name = '' WHERE display_name IS NULL;
ALTER TABLE participants ALTER COLUMN display_name SET NOT NULL;
```

**4.3 Safe Removal of a Column**

```sql
ALTER TABLE proposed_slots RENAME COLUMN duration_minutes TO duration_old;
ALTER TABLE proposed_slots ADD COLUMN duration_seconds INTEGER;
UPDATE proposed_slots SET duration_seconds = duration_old * 60;
ALTER TABLE proposed_slots DROP COLUMN duration_old;
```

### 5. Constraint Interaction Notes

- State machine constraints interact with event creation rules.
- Expiry rules override user actions.
- Participants table drives access control.
- JSON snapshots must reflect normalized tables.
- Agent mode affects negotiation lifecycle rules.

### 6. Summary

- SQL constraints provide structural integrity.
- Application constraints enforce behavior.
- Migration rules ensure long-term stability.
- Frozen constraints prevent dangerous refactors.
- Evolvable constraints allow product expansion without breaking production.

## Indexing Strategy

This section defines the global indexing strategy for the Kairos Amiqo PostgreSQL schema. It consolidates table-level index definitions, explains the query patterns they support, and specifies rules for adding or changing indexes in future migrations.

Indexes must:
- Directly support real query patterns from the iOS app and backend.
- Avoid over-indexing that hurts write performance.
- Respect E2EE boundaries (no indexing on encrypted blobs).

### 1. Existing Indexes by Table

**1.1 negotiations**

Primary access patterns:
- "List my active invitations" (by owner, state, and expiry).
- "List all negotiations that are still active" (global or filtered by owner).

Indexes:
```sql
-- Frequently queried by owner
CREATE INDEX idx_negotiations_owner ON negotiations(owner);

-- State + expiry filtering (list of invitations)
CREATE INDEX idx_negotiations_state_expires
  ON negotiations(state, expires_at);

-- Active negotiations only (partial index)
CREATE INDEX idx_negotiations_active
  ON negotiations(expires_at)
  WHERE state IN ('awaiting_invites', 'awaiting_replies');
```

Rationale:
- `idx_negotiations_owner` supports the common pattern: "All negotiations I created".
- `idx_negotiations_state_expires` supports listing-active/future invitations with pagination.
- `idx_negotiations_active` accelerates global active-queries without scanning expired rows.

**1.2 participants**

Primary access patterns:
- "Which users are part of negotiation X?"
- "Which negotiations is user Y part of?"
- "What accepted/confirmed invitations does user Y have?"

Indexes:
```sql
-- All participants for a negotiation
CREATE INDEX idx_participants_negotiation ON participants(negotiation_id);

-- All negotiations a user is participating in
CREATE INDEX idx_participants_user ON participants(user_id);

-- Filter by user and status (e.g., accepted invitations)
CREATE INDEX idx_participants_user_status
  ON participants(user_id, status);
```

Rationale:
- `idx_participants_negotiation` supports loading participant lists when viewing a negotiation.
- `idx_participants_user` supports building "My invitations" lists from participant membership.
- `idx_participants_user_status` supports queries like "all accepted invitations for me".

**1.3 proposed_slots**

Primary access patterns:
- "List all candidate time slots for negotiation X".
- "Find upcoming slots for ranking/batching".

Indexes:
```sql
-- All slots for a negotiation
CREATE INDEX idx_proposed_slots_negotiation
  ON proposed_slots(negotiation_id);

-- Time-based queries on slots
CREATE INDEX idx_proposed_slots_starts_at
  ON proposed_slots(starts_at);
```

Rationale:
- Negotiation-level index supports quick slot lookup.
- Time-based index allows future features like "next available slot" across negotiations.

**1.4 proposed_venues**

Primary access patterns:
- "List all candidate venues for a negotiation".
- Future: filter by venue name or provider.

Indexes:
```sql
-- All venues for a negotiation
CREATE INDEX idx_proposed_venues_negotiation
  ON proposed_venues(negotiation_id);

-- Future-friendly index for name-based search
CREATE INDEX idx_proposed_venues_name
  ON proposed_venues(name);
```

Rationale:
- Negotiation-level index supports venue list retrieval.
- Name index is cheap now and prepares for basic search or grouping without full-text.

**1.5 events**

Primary access patterns:
- "List my upcoming events".
- "List events derived from a specific negotiation".
- "Find confirmed events only".

Indexes:
```sql
-- Primary query: my upcoming events
CREATE INDEX idx_events_owner_starts_at
  ON events(owner, starts_at);

-- Filter by status (draft/confirmed/cancelled)
CREATE INDEX idx_events_status
  ON events(status);

-- Link back to a negotiation
CREATE INDEX idx_events_negotiation
  ON events(negotiation_id);
```

Rationale:
- `idx_events_owner_starts_at` supports calendar-style queries for a user.
- `idx_events_status` supports backend maintenance and analytics.
- `idx_events_negotiation` supports event lookups when viewing a negotiation.

### 2. Query Patterns and Index Coverage

This subsection summarizes how indexes map to real-world queries.

**2.1 Invitations List (Owner Perspective)**  
- API: "List all active invitations I created"
- Query pattern:
  - Filter by `owner = :user_id`
  - Filter by `state IN ('awaiting_invites','awaiting_replies')`
  - Filter or order by `expires_at`
- Covered by:
  - `idx_negotiations_owner`
  - `idx_negotiations_state_expires`
  - `idx_negotiations_active`

**2.2 Invitations List (Participant Perspective)**  
- API: "List all invitations where I am a participant"
- Query pattern:
  - Find negotiations via `participants.user_id = :user_id`
  - Join back to negotiations
- Covered by:
  - `idx_participants_user`
  - `idx_participants_user_status`

**2.3 Upcoming Events**  
- API: "List my events sorted by start time"
- Query pattern:
  - Filter by `owner = :user_id`
  - Filter by `status = 'confirmed'` (typically)
  - Order by `starts_at`
- Covered by:
  - `idx_events_owner_starts_at`
  - `idx_events_status`

**2.4 Negotiation Detail View**  
- API: "Load one negotiation + its participants + proposals"
- Query pattern:
  - `SELECT * FROM negotiations WHERE id = :id`
  - `SELECT * FROM participants WHERE negotiation_id = :id`
  - `SELECT * FROM proposed_slots WHERE negotiation_id = :id`
  - `SELECT * FROM proposed_venues WHERE negotiation_id = :id`
- Covered by:
  - Primary key on `negotiations.id`
  - `idx_participants_negotiation`
  - `idx_proposed_slots_negotiation`
  - `idx_proposed_venues_negotiation`

### 3. Indexing Rules and Anti-Patterns

To keep the schema maintainable and performant:

1. **Do not index encrypted payloads.**  
   - No indexes on any future encrypted content columns.
   - Index only metadata (owner, state, status, timestamps).

2. **Avoid overlapping indexes.**  
   - Before adding a new index, verify it is not already covered by existing ones.
   - Example: do not add both `(owner)` and `(owner, state)` if only the second is needed.

3. **Index only proven query patterns.**  
   - New indexes must be justified by:
     - API contracts;
     - Slow query logs;
     - Observability metrics.

4. **Beware of high-cardinality + low-selectivity combinations.**  
   - Do not add broad single-column indexes on booleans or low-cardinality TEXT fields unless necessary.

5. **Keep partial indexes simple.**  
   - Partial indexes (like `idx_negotiations_active`) must have clear predicates that match code.

### 4. Future Index Extensions

The following index types are not part of the MVP but may be added later:

1. **GIN / GIST indexes on JSONB metadata**  
   - For advanced querying on `events.metadata` or future metadata fields.

2. **Full-text search indexes**  
   - Only for non-sensitive metadata (e.g., venue names), never for encrypted content.

3. **Composite indexes for analytics**  
   - For internal dashboards and reporting, not user-facing flows.

All such indexes must:
- Respect E2EE boundaries.
- Be added via migrations that include rollback plans.

### 5. Migration and Maintenance Considerations

1. **Adding an index**  
   - Use `CREATE INDEX CONCURRENTLY` in production to avoid write blocking.

2. **Dropping unused indexes**  
   - Monitor index usage via PostgreSQL statistics.
   - Remove indexes that show negligible usage over a significant period.

3. **Adapting to new query patterns**  
   - Introduce new indexes only after the corresponding API usage is stable.

4. **Testing**  
   - Include `EXPLAIN` plans in performance tests for critical endpoints.

### 6. Summary

- Indexes are tightly aligned with real query patterns from the iOS app and backend.
- Negotiations, participants, slots, venues, and events each have purpose-built indexes.
- No indexes are defined on encrypted content; metadata-only indexing preserves E2EE.
- Future index additions must follow clear rules and migration safety practices.

## Referential Integrity

This section defines how tables relate to each other through foreign keys and application-level consistency rules. The Kairos Amiqo schema uses **Option A (ON DELETE RESTRICT)** as the canonical strategy for most foreign keys to preserve historical data and prevent accidental cascading deletions.

### 2.1 SQL Referential Integrity (Hard FKs)

All foreign key relationships and their deletion/update behaviors:

| Child Table | Column | Parent Table | Parent Column | ON DELETE | ON UPDATE |
|-------------|--------|--------------|---------------|-----------|------------|
| `participants` | `negotiation_id` | `negotiations` | `id` | **RESTRICT** | CASCADE |
| `proposed_slots` | `negotiation_id` | `negotiations` | `id` | **RESTRICT** | CASCADE |
| `proposed_venues` | `negotiation_id` | `negotiations` | `id` | **RESTRICT** | CASCADE |
| `events` | `negotiation_id` | `negotiations` | `id` | **RESTRICT** | CASCADE |
| `negotiations` | `owner` | `app_users` | `id` | CASCADE | CASCADE |
| `events` | `owner` | `app_users` | `id` | CASCADE | CASCADE |
| `participants` | `user_id` | (none) | — | — | — |

**Note**: `participants.user_id` does NOT have a foreign key to an `app_users` table because Firebase is the identity provider. User IDs are Firebase `sub` claims validated at the application layer.

**Why ON DELETE RESTRICT for negotiations?**

1. **Negotiations must never be auto-deleted.**  
   - Deleting a negotiation would cascade to participants, slots, venues, and potentially events.
   - This violates historical data preservation requirements.

2. **Dependent tables must never cascade deletion upward.**  
   - If a participant is removed, the negotiation should NOT be deleted.
   - If a slot/venue is removed, the negotiation should remain intact.

3. **Historical data must be preserved.**  
   - Analytics, AI learning, and revival flows require immutable metadata lineage.
   - Even cancelled negotiations retain value for pattern detection and user behavior analysis.

4. **E2EE boundaries require immutable metadata lineage.**  
   - Metadata history enables audit trails without decrypting content.
   - Deletion of metadata breaks the ability to verify negotiation state transitions.

**Why ON DELETE CASCADE for app_users?**

- When a user account is permanently deleted (GDPR, account closure), all their negotiations and events must be removed.
- This is a deliberate, user-initiated action that should cascade.
- User deletion is rare and requires explicit confirmation.

### 2.2 Application-Level Referential Integrity

These rules are enforced by backend logic, not SQL constraints:

**Organizer Membership Rule:**  
- The negotiation owner MUST have a participant row with `status = 'organizer'`.
- Backend must create this row automatically when a negotiation is created.
- Organizer row cannot be deleted while the negotiation exists.

**Minimum Participant Count:**  
- Every negotiation must have ≥ 1 participant (the organizer).
- Backend must reject participant deletions that would leave zero participants.

**Slot and Venue Count Consistency:**  
- Slot/venue counts in normalized tables must match snapshot JSON counts.
- Backend must sync `proposed_slots_json` and `proposed_venues_json` after any slot/venue mutation.
- Normalized tables (`proposed_slots`, `proposed_venues`) remain the source of truth.

**Status Transition Validation:**  
- State transitions must be validated against participant data:
   - `awaiting_invites` → `awaiting_replies` requires ≥ 1 invited participant.
   - `awaiting_replies` → `confirmed` requires consensus detection (all participants accepted or majority rule).
   - `confirmed` → `cancelled` is always allowed.
- Backend must reject invalid state transitions.

**Negotiations with Events Cannot Regress:**  
- Once an event is created from a negotiation, the negotiation cannot move to earlier states.
- Example: `confirmed` negotiation with an event cannot move back to `awaiting_replies`.
- Backend must enforce this at the service layer.

**Revival Logic (Cancelled → Recreated):**  
- Revival must keep lineage but create new rows.
- Original negotiation remains in `cancelled` state.
- New negotiation created with a reference to the original (future: `parent_negotiation_id`).
- This preserves audit history and prevents state corruption.

### 2.3 Cross-Table Consistency Rules

**Negotiation → Participants → Access Control:**  
- `user_id` in `participants` table determines membership.
- Authorization checks MUST use the `participants` table, not client-supplied data.
- Backend validates that the authenticated user (Firebase `sub`) matches a participant row.

**Negotiation → Slots/Venues → State Transitions:**  
- `awaiting_invites`: Organizer proposes slots/venues.
- `awaiting_replies`: Participants respond to proposals.
- `confirmed`: Exactly one slot and one venue are selected (or consensus algorithm determines final choice).
- Backend enforces these rules in the service layer.

**Negotiation → Event Generation (One-Way Link):**  
- Events are created FROM negotiations (one-way relationship).
- `events.negotiation_id` points back to the source negotiation.
- Deleting a negotiation does NOT delete the event (ON DELETE RESTRICT).
- This preserves the event on the user's calendar even if the negotiation is archived.

**JSON Snapshot Sync Rules:**  
- `proposed_slots_json` and `proposed_venues_json` are **read-only snapshots** for API responses.
- Normalized tables (`proposed_slots`, `proposed_venues`) are the **source of truth**.
- Backend must regenerate JSON snapshots after any mutation to slots/venues.
- Migrations must never rely on JSON snapshots for data integrity.

### 2.4 Migration Impact Notes

**Frozen Foreign Keys (Do Not Change After Launch):**  
- The core FK graph (negotiations ↔ participants/slots/venues/events) is frozen.
- Changing ON DELETE behavior requires:
   1. Application-level coordination (ensure no active transactions).
   2. Downtime or careful blue-green deployment.
   3. Data migration to handle existing rows.
- **Prohibited operations**:
   - Changing `ON DELETE RESTRICT` to `ON DELETE CASCADE` on core FKs.
   - Dropping `participants.negotiation_id` FK.
   - Dropping `events.negotiation_id` FK.

**Safe FK Addition Pattern:**  
1. Add new optional column with default NULL.
2. Backfill data if needed.
3. Add FK constraint using `NOT VALID` (allows existing rows).
4. Validate constraint: `ALTER TABLE ... VALIDATE CONSTRAINT ...`.
5. Update application code to enforce FK at insert/update time.

**Safe FK Removal Pattern:**  
1. Remove FK constraint: `ALTER TABLE ... DROP CONSTRAINT ...`.
2. Deploy application code that no longer relies on FK.
3. Optionally drop the column in a future migration.

**Safe Schema Extension:**  
- **Adding optional columns**: Always safe with default values.
- **Adding new tables**: Safe if they don't reference core tables with RESTRICT FKs.
- **Adding indexes**: Always safe (use CONCURRENTLY in production).
- **Adding JSONB fields**: Safe; application must handle missing keys.

**Unsafe Operations:**  
- Renaming FK columns without coordinated application deployment.
- Changing FK parent table (requires data migration).
- Adding NOT NULL constraints without backfill.

<!-- Completed: P2.S1.T5.ST5.SP2 -->

## Migration Rules

### 6.1 Overview

The Kairos Amiqo database schema follows **strict additive, forward-only migrations** to maintain production stability, preserve historical data, and respect E2EE boundaries.

**Core Principles:**

1. **Zero-Downtime Requirement**  
   - All migrations must be compatible with running applications.
   - No blocking DDL operations during peak traffic.
   - Use `CREATE INDEX CONCURRENTLY` and `NOT VALID` constraints.

2. **E2EE Boundary Constraints**  
   - Metadata lineage cannot be rewritten or deleted.
   - Historical negotiation states must remain queryable for analytics and AI learning.
   - Even cancelled negotiations retain immutable metadata for audit trails.

3. **Irreversible Schema Changes Are Heavily Restricted**  
   - Once a migration is deployed to production, it cannot be rolled back.
   - Destructive changes (dropping columns, renaming tables) require multi-phase deployments.
   - Schema evolution must be additive wherever possible.

4. **Firebase Auth Identity Immutability**  
   - `user_id` references are Firebase `sub` claims (never stored in `app_users` table).
   - User identity is immutable; schema cannot enforce FK to a local users table.
   - Application layer validates Firebase tokens; database stores only UUID references.

5. **Forward-Only Philosophy**  
   - Migrations are numbered sequentially and applied in order.
   - No squashing, reordering, or deletion of historical migrations.
   - Each migration file is permanent and forms part of the schema's version history.

### 6.2 Migration Categories

Migrations fall into three categories based on safety and reversibility:

**Additive (Safe)**  
These migrations are fully safe and non-disruptive:

- Adding a new nullable column
- Adding a new table (not referenced by existing FKs)
- Adding a new index (using `CONCURRENTLY`)
- Adding new JSONB fields to existing metadata columns
- Adding new enum values to CHECK constraints (via `NOT VALID` → `VALIDATE`)
- Adding new optional foreign keys (nullable, with safe backfill)

**Examples:**
```sql
-- Safe: Add nullable column
ALTER TABLE negotiations ADD COLUMN priority INTEGER DEFAULT 1;

-- Safe: Add new table
CREATE TABLE reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    negotiation_id UUID NOT NULL REFERENCES negotiations(id),
    remind_at TIMESTAMPTZ NOT NULL
);

-- Safe: Add index concurrently
CREATE INDEX CONCURRENTLY idx_negotiations_priority ON negotiations(priority);
```

**Evolvable (Cautious)**  
These migrations require multi-step sequences:

- Adding a required (NOT NULL) column
- Adding a foreign key to an existing column
- Extending CHECK constraints with new values
- Converting nullable columns to NOT NULL
- Changing column defaults

**Examples:**
```sql
-- Step 1: Add nullable column
ALTER TABLE participants ADD COLUMN last_seen_at TIMESTAMPTZ;

-- Step 2: Backfill data
UPDATE participants SET last_seen_at = updated_at WHERE last_seen_at IS NULL;

-- Step 3: Make NOT NULL
ALTER TABLE participants ALTER COLUMN last_seen_at SET NOT NULL;
```

**Destructive (Forbidden)**  
These operations are prohibited in production without downtime:

- Removing columns
- Renaming columns or tables
- Changing primary key columns
- Changing ON DELETE/ON UPDATE rules
- Altering data types of core columns
- Rewriting historical rows
- Squashing or deleting migration files

### 6.3 Allowed Migration Patterns

**Pattern 1: Adding a Nullable Column**

```sql
-- Always safe
ALTER TABLE events ADD COLUMN location_hint TEXT;
```

**Pattern 2: Adding a Required Column (Multi-Step)**

```sql
-- Migration 1: Add nullable column with default
ALTER TABLE negotiations ADD COLUMN timezone TEXT DEFAULT 'UTC';

-- Migration 2: Backfill missing values
UPDATE negotiations SET timezone = 'UTC' WHERE timezone IS NULL;

-- Migration 3: Make NOT NULL
ALTER TABLE negotiations ALTER COLUMN timezone SET NOT NULL;
```

**Pattern 3: Adding a Foreign Key Safely**

```sql
-- Migration 1: Add nullable column
ALTER TABLE events ADD COLUMN reminder_id UUID;

-- Migration 2: Backfill data (if needed)
-- UPDATE events SET reminder_id = ... WHERE ...;

-- Migration 3: Add FK constraint using NOT VALID
ALTER TABLE events
  ADD CONSTRAINT fk_events_reminder
  FOREIGN KEY (reminder_id) REFERENCES reminders(id)
  NOT VALID;

-- Migration 4: Validate constraint
ALTER TABLE events VALIDATE CONSTRAINT fk_events_reminder;

-- Migration 5 (optional): Make NOT NULL if required
ALTER TABLE events ALTER COLUMN reminder_id SET NOT NULL;
```

**Pattern 4: Adding Indexes Safely**

```sql
-- Always use CONCURRENTLY in production
CREATE INDEX CONCURRENTLY idx_events_location_hint ON events(location_hint);
```

**Pattern 5: Adding CHECK Constraints Safely**

```sql
-- Step 1: Add new constraint with NOT VALID
ALTER TABLE negotiations
  ADD CONSTRAINT chk_intent_extended
  CHECK (intent_category IN ('coffee','lunch','dinner','drinks','gym','walk','movie','concert','study','game','brunch','breakfast'))
  NOT VALID;

-- Step 2: Validate constraint
ALTER TABLE negotiations VALIDATE CONSTRAINT chk_intent_extended;

-- Step 3: Drop old constraint (if replacing)
ALTER TABLE negotiations DROP CONSTRAINT chk_intent_category;
```

**Pattern 6: Safe Extension of JSONB Fields**

```sql
-- Always safe: JSONB fields are schemaless
-- Application code handles new/missing keys gracefully
-- No migration needed; just update application code
```

### 6.4 Prohibited Operations

The following operations are **forbidden** in production without coordinated downtime:

**1. Dropping or Renaming Primary Key Columns**  
- Would break all foreign key references.
- Requires application code changes across all services.

**2. Changing ON DELETE/ON UPDATE Rules**  
- Example: Changing `ON DELETE RESTRICT` to `ON DELETE CASCADE`.
- Would alter referential integrity behavior unpredictably.
- Requires application-level coordination.

**3. Renaming Foreign Key Columns**  
- Breaks queries and application code simultaneously.
- Requires coordinated blue-green deployment.

**4. Altering Data Types of Core Columns**  
- Example: Changing `expires_at` from `TIMESTAMPTZ` to `DATE`.
- Risks data loss and type coercion errors.
- Requires multi-phase migration with shadow columns.

**5. Removing Columns Without Downtime**  
- Must follow: deploy code that ignores column → remove column in later migration.
- Single-step removal causes runtime errors.

**6. Rewriting Historical Rows**  
- Prohibited due to E2EE boundary integrity.
- Metadata lineage must remain immutable for audit trails.
- Even "data fixes" require new rows, not updates.

**7. Squashing or Reordering Previous Migration Files**  
- Breaks version history and deployment consistency.
- Migration files are permanent records.

**8. Changing UNIQUE Constraints on Core Tables**  
- Example: Changing `(negotiation_id, user_id)` UNIQUE constraint on `participants`.
- Would allow duplicate participant rows.

### 6.5 Example Migration Sequences

**Example 1: Add a New Optional JSONB Column**

```sql
-- Migration: 0042_add_negotiation_metadata.sql
ALTER TABLE negotiations ADD COLUMN extra_metadata JSONB DEFAULT '{}'::jsonb NOT NULL;
```

**Example 2: Add a Required Column Safely (Multi-Step)**

```sql
-- Migration: 0043_add_priority_step1.sql
ALTER TABLE negotiations ADD COLUMN priority INTEGER DEFAULT 5;

-- Migration: 0044_add_priority_step2.sql
UPDATE negotiations SET priority = 5 WHERE priority IS NULL;

-- Migration: 0045_add_priority_step3.sql
ALTER TABLE negotiations ALTER COLUMN priority SET NOT NULL;
```

**Example 3: Add a New Intent Category (CHECK Extension)**

```sql
-- Migration: 0046_extend_intent_categories.sql

-- Step 1: Add new constraint with extended values
ALTER TABLE negotiations
  ADD CONSTRAINT chk_intent_category_v2
  CHECK (intent_category IN (
    'coffee','lunch','dinner','drinks','gym','walk','movie',
    'concert','study','game','brunch','breakfast','hike'
  ))
  NOT VALID;

-- Step 2: Validate new constraint
ALTER TABLE negotiations VALIDATE CONSTRAINT chk_intent_category_v2;

-- Step 3: Drop old constraint
ALTER TABLE negotiations DROP CONSTRAINT chk_intent_category;

-- Step 4: Rename new constraint (optional)
ALTER TABLE negotiations RENAME CONSTRAINT chk_intent_category_v2 TO chk_intent_category;
```

**Example 4: Add a New Normalized Table (Reminders)**

```sql
-- Migration: 0047_create_reminders_table.sql

CREATE TABLE reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    negotiation_id UUID NOT NULL,
    user_id UUID NOT NULL,
    remind_at TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'sent', 'cancelled')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT fk_reminders_negotiation FOREIGN KEY (negotiation_id)
        REFERENCES negotiations(id)
        ON DELETE CASCADE
);

CREATE INDEX idx_reminders_negotiation ON reminders(negotiation_id);
CREATE INDEX idx_reminders_user_status ON reminders(user_id, status);
CREATE INDEX idx_reminders_remind_at ON reminders(remind_at) WHERE status = 'pending';
```

**Example 5: Add a Foreign Key the Safe Way**

```sql
-- Migration: 0048_add_event_reminder_fk_step1.sql
ALTER TABLE events ADD COLUMN reminder_id UUID;

-- Migration: 0049_add_event_reminder_fk_step2.sql
-- Backfill if needed (or leave NULL for now)
-- UPDATE events SET reminder_id = ... WHERE ...;

-- Migration: 0050_add_event_reminder_fk_step3.sql
ALTER TABLE events
  ADD CONSTRAINT fk_events_reminder
  FOREIGN KEY (reminder_id) REFERENCES reminders(id)
  ON DELETE SET NULL
  NOT VALID;

-- Migration: 0051_add_event_reminder_fk_step4.sql
ALTER TABLE events VALIDATE CONSTRAINT fk_events_reminder;
```

### 6.6 Versioning & Ordering Rules

**Migration Filename Convention:**
```
NNNN_description.sql
```

Examples:
```
0001_init_schema.sql
0002_add_participants_table.sql
0003_add_proposed_slots_table.sql
0004_add_events_table.sql
0005_add_negotiation_priority.sql
```

**Rules:**

1. **Always Forward-Only**  
   - Migrations are applied sequentially in numeric order.
   - Once applied, a migration cannot be undone.

2. **Never Rewrite or Delete Old Migrations**  
   - Each migration file is permanent.
   - Squashing or deleting breaks version history.

3. **Dependencies Between Migrations**  
   - Migration `NNNN` can depend on all migrations `< NNNN`.
   - Cannot reference future migrations.

4. **Flyway-Style Linear Progression**  
   - Each migration has a unique version number.
   - Migrations are checksummed to detect tampering.

5. **iOS and Backend Must Coordinate Schema Version**  
   - Backend exposes a `/health` endpoint with `schema_version`.
   - iOS checks schema compatibility before making requests.
   - Version constant stored in `backend/src/config/schema-version.js`.

**Example Version Check:**
```javascript
// backend/src/config/schema-version.js
export const SCHEMA_VERSION = 51; // Matches migration 0051_*

// backend/src/routes/health.js
fastify.get('/health', async (request, reply) => {
  return {
    status: 'ok',
    schema_version: SCHEMA_VERSION
  };
});
```

**Handling Migration Failures:**

- Failed migrations must be manually resolved.
- Never delete a failed migration file.
- Fix forward by adding a new migration.

**Example:**
```sql
-- 0052_fix_priority_default.sql
-- Fixes incorrect default value from 0051
ALTER TABLE negotiations ALTER COLUMN priority SET DEFAULT 3;
UPDATE negotiations SET priority = 3 WHERE priority = 5;
```

### 6.7 Summary

**Key Principles:**

- **Additive-first evolution**: New columns, tables, and indexes are preferred over modifications.
- **Immutable metadata lineage**: Historical data cannot be rewritten; respects E2EE boundaries.
- **Zero-downtime requirements**: All migrations must be compatible with running applications.
- **Forward-only migrations**: No rollbacks, no squashing, no reordering.
- **Multi-step safety**: Destructive changes require phased deployments.
- **Coordinated schema versioning**: iOS and backend track schema compatibility.

**Allowed Operations:**
- Add nullable columns
- Add new tables with safe FKs
- Add indexes concurrently
- Extend CHECK constraints safely
- Add JSONB fields (schemaless)

**Forbidden Operations:**
- Drop/rename columns or tables
- Change PK/FK rules
- Alter core data types
- Rewrite historical rows
- Delete migration files

**Migration Workflow:**
1. Write migration in `backend/migrations/NNNN_description.sql`
2. Test locally with full schema rebuild
3. Deploy to staging
4. Validate with integration tests
5. Deploy to production using `CREATE INDEX CONCURRENTLY` and `NOT VALID` patterns
6. Update schema version constant

<!-- Completed: P2.S1.T5.ST6.SP2 -->

## Status

### Completion Summary

The Kairos Amiqo database schema is **fully defined and production-ready**:

- **All 5 core tables specified**: `negotiations`, `participants`, `proposed_slots`, `proposed_venues`, `events`
- **Complete constraint coverage**: Primary keys, foreign keys, UNIQUE constraints, CHECK constraints, NOT NULL enforcement
- **Comprehensive indexing strategy**: 14 indexes mapped to 4 primary query patterns
- **Referential integrity rules**: ON DELETE RESTRICT strategy for historical preservation, ON DELETE CASCADE for user deletion, ON DELETE SET NULL for event unlinking
- **Data type conventions**: UUID PKs, TIMESTAMPTZ for all timestamps, JSONB for metadata, TEXT+CHECK for enums
- **Migration governance**: Forward-only, additive-first, zero-downtime rules with 6 canonical safe patterns and 8 prohibited operations

**Architectural Alignment:**
- Fully aligned with new backend architecture (Fastify + PostgreSQL + Firebase Auth)
- E2EE boundaries respected: metadata-only storage, no encrypted payloads in database
- Zero legacy references (no Directus, Node-RED, or mock-server dependencies)

**Status**: Ready for Phase 3 (Backend Implementation)

### Architectural Alignment

This schema is the **single source of truth** for all database operations and directly supports the API contracts defined in `docs/02-api-contracts.md`:

**1. Negotiation Lifecycle Mapping**

The negotiation state machine maps 1:1 with database constraints:

| API State | Database Value | Enforced By |
|-----------|---------------|-------------|
| `awaiting_invites` | `state = 'awaiting_invites'` | CHECK constraint |
| `awaiting_replies` | `state = 'awaiting_replies'` | CHECK constraint |
| `accepted` | `state = 'accepted'` | CHECK constraint |
| `cancelled` | `state = 'cancelled'` | CHECK constraint |
| `expired` | `state = 'expired'` | CHECK constraint |

**2. Normalized Tables as Source of Truth**

- `participants` table drives invitation status and participant counts
- `proposed_slots` table stores all slot options with `slot_index` ordering
- `proposed_venues` table stores all venue options with `venue_index` ordering
- `negotiations.proposed_slots_json` and `negotiations.proposed_venues_json` are **convenience snapshots only** for API responses
- Backend must query normalized tables for all business logic

**3. Foreign Key Alignment**

All foreign keys follow the referential integrity strategy defined in Section 5.2:

- `negotiations.owner` → `app_users(id)` with ON DELETE CASCADE
- `participants.negotiation_id` → `negotiations(id)` with ON DELETE RESTRICT
- `proposed_slots.negotiation_id` → `negotiations(id)` with ON DELETE RESTRICT
- `proposed_venues.negotiation_id` → `negotiations(id)` with ON DELETE RESTRICT
- `events.owner` → `app_users(id)` with ON DELETE CASCADE
- `events.negotiation_id` → `negotiations(id)` with ON DELETE SET NULL (nullable)

**4. E2EE Boundary Compliance**

- Database stores **metadata only**: titles, states, timestamps, participant IDs
- Encrypted payloads (messages, detailed venue info, personal notes) live client-side
- JSONB `metadata` columns store non-sensitive contextual data only
- Historical negotiation states remain queryable for analytics without exposing private content

**5. Firebase Auth Integration**

- `user_id` columns reference Firebase `sub` claims (not local user table)
- Backend validates Firebase JWT tokens; database stores UUID references only
- `app_users` table exists for Firebase UID → local metadata mapping
- User identity is immutable; schema does not enforce FK to `app_users.firebase_uid`

### Constraints & Migration Freeze

**Core Schema Freeze (Effective Immediately)**

The following elements are now **frozen for Phase 3 implementation**:

1. **Table Names & Primary Keys**
   - All 5 table names are fixed: `negotiations`, `participants`, `proposed_slots`, `proposed_venues`, `events`
   - All tables use `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - No renaming or PK changes allowed

2. **Foreign Key Relationships**
   - ON DELETE rules are frozen (RESTRICT for children, CASCADE for app_users, SET NULL for events)
   - Cannot change to CASCADE/SET NULL without multi-phase deployment
   - All FK column names are fixed

3. **Core Columns**
   - Cannot remove or rename: `state`, `intent_category`, `owner`, `negotiation_id`, `user_id`, `starts_at`, `status`
   - Cannot change data types: TIMESTAMPTZ → DATE, UUID → TEXT, etc.
   - Cannot alter CHECK constraint values without following Section 6.3 safe patterns

4. **UNIQUE Constraints**
   - `(negotiation_id, user_id)` on `participants` is frozen
   - `(negotiation_id, slot_index)` on `proposed_slots` is frozen
   - `(negotiation_id, venue_index)` on `proposed_venues` is frozen

**Allowed Future Changes (Follow Section 6 Migration Rules)**

All changes must be **additive, forward-only, and zero-downtime**:

- ✅ Add nullable columns (e.g., `priority INTEGER`)
- ✅ Add new tables (e.g., `reminders`, `notifications`)
- ✅ Add indexes using `CREATE INDEX CONCURRENTLY`
- ✅ Add JSONB fields to `metadata` columns
- ✅ Extend CHECK constraints using `NOT VALID` → `VALIDATE` pattern
- ✅ Add required columns using 3-step backfill pattern

**Prohibited Operations**

- ❌ Drop or rename columns
- ❌ Change ON DELETE/ON UPDATE rules
- ❌ Alter core data types
- ❌ Rewrite historical rows
- ❌ Remove CHECK constraint values
- ❌ Squash or reorder migration files

**Migration Governance**

All schema changes must follow the **Migration Rules** defined in Section 6:

1. Forward-only migrations numbered sequentially (`0001_init.sql`, `0002_add_reminders.sql`, etc.)
2. Zero-downtime patterns (CONCURRENTLY, NOT VALID → VALIDATE, multi-step backfills)
3. iOS and backend coordinate schema version via `/health` endpoint
4. No rollbacks; fix forward by adding new migrations

**Backend Implementation Requirements**

Phase 3 backend engineers must:

- Implement schema exactly as defined in this document
- Use Prisma or equivalent ORM with migration tooling
- Never deviate from column names, types, or constraints
- Follow Section 6 migration patterns for all future changes

### Handoff to Phase 3

**Backend Implementation Checklist**

The following work is now **unblocked and ready for Phase 3**:

**1. Database Setup**

- [ ] Initialize PostgreSQL 15+ instance (local dev: Docker; production: Cloud SQL)
- [ ] Configure connection pooling (recommended: 10-20 connections per instance)
- [ ] Set timezone to UTC: `SET TIME ZONE 'UTC';`
- [ ] Enable UUID extension: `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`

**2. ORM & Migration Tooling**

- [ ] Install Prisma (recommended) or TypeORM
- [ ] Create `backend/prisma/schema.prisma` from this document
- [ ] Generate first migration: `0001_init_schema.sql` with all 5 tables
- [ ] Test migration locally: `npx prisma migrate dev`
- [ ] Verify all indexes, constraints, and FKs are created

**3. Fastify Integration**

- [ ] Implement database connection plugin (`backend/src/plugins/database.js`)
- [ ] Configure Prisma client singleton
- [ ] Add health check endpoint exposing schema version (see Section 6.6)
- [ ] Implement graceful shutdown for DB connections

**4. Data Access Layer**

- [ ] Create service modules for each table:
  - `backend/src/services/negotiations.service.js`
  - `backend/src/services/participants.service.js`
  - `backend/src/services/proposed-slots.service.js`
  - `backend/src/services/proposed-venues.service.js`
  - `backend/src/services/events.service.js`
- [ ] Implement CRUD operations respecting constraints
- [ ] Add query helpers for common patterns (active invitations, upcoming events, etc.)

**5. Schema Validation**

- [ ] Validate CHECK constraints in application layer before writes
- [ ] Enforce business rules (organizer must be participant, minimum 2 participants, etc.)
- [ ] Add pre-commit hooks to prevent schema drift

**6. iOS Alignment**

iOS team can begin:

- [ ] Updating Core Data models to match final column names
- [ ] Aligning `NegotiationDTO` field names with database columns
- [ ] Implementing schema version check in API client
- [ ] Testing migration from mock data to real backend

**7. Testing Requirements**

- [ ] Write integration tests for all CRUD operations
- [ ] Test all 14 indexes with `EXPLAIN ANALYZE`
- [ ] Validate referential integrity (ON DELETE behavior)
- [ ] Test zero-downtime migration patterns
- [ ] Benchmark query performance with realistic dataset (1000+ negotiations)

**Canonical Reference**

This document (`docs/04-database-schema.md`) is now the **single source of truth** for:

- All database schema decisions
- Migration patterns and governance
- Constraint definitions and rationale
- Query optimization strategy
- Phase 3 backend implementation

**Change Control**: Any proposed schema changes must be reviewed against Section 6 (Migration Rules) before implementation.

**Phase 3 Status**: Backend implementation can proceed immediately.

<!-- Completed: P2.S1.T5.ST6.SP3 -->
